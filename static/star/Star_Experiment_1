<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title>The Starfield Game</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <link href="https://maxcdn.bootstrapcdn.com/bootstrap/4.5.2/css/bootstrap.min.css" rel="stylesheet">
    <link href="/css/experiments.css" rel="stylesheet">
    <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
    <link rel="manifest" href="/site.webmanifest">
    <link rel="stylesheet" href="https://unpkg.com/jspsych@latest/css/jspsych.css">
    <style>
      html, body { margin: 0; padding: 0; height: 100%; background: #808080; }
      #rdk-canvas { display: block; margin: 0 auto; background: #808080; }
      .center { color: #ddd; max-width: 800px; margin: 40px auto; line-height: 1.6; padding: 0 20px; }
      .center h2, .center h3 { color: #fff; }
      .survey-option {
        display: inline-block;
        padding: 10px 20px;
        margin: 5px;
        background: #555;
        color: white;
        border-radius: 5px;
        cursor: pointer;
      }
      .survey-option:hover {
        background: #666;
      }
      .stimulus-container {
        position: relative;
        width: 800px;
        height: 800px;
        margin: 0 auto;
        background: #808080;
      }
      .face-image, .tree-image {
        position: absolute;
      }
    </style>
    <script src="https://unpkg.com/jspsych@latest/dist/index.browser.js"></script>
    <script src="https://unpkg.com/@jspsych/plugin-html-keyboard-response@latest/dist/index.browser.js"></script>
  </head>
  <body>
  <script>
    const jsPsych = initJsPsych({});

  // Configure Google Form prefill - UPDATED WITH MTURK FORM URL
  // Base form URL (params will be appended automatically). UUID will be added to entry.766586855
  const GOOGLE_FORM_BASE_URL = 'https://docs.google.com/forms/d/e/1FAIpQLSetUbx3GaRBXk5yOJ2JehjL2t78A2PlY7FpPqwpBPOMAfWlvA/viewform';
    const GOOGLE_FORM_ENTRY_ID = '766586855'; // Same entry ID as provided in your URL
    // Optional: set entry IDs for MTurk fields if you have corresponding questions in the form
    const GOOGLE_FORM_ASSIGNMENT_ENTRY_ID = ''; // Update these if your new form has these fields
    const GOOGLE_FORM_WORKER_ENTRY_ID = '';
    const GOOGLE_FORM_HIT_ENTRY_ID = '';

    // Capture MTurk params from query string
    function getParam(name) {
      const m = new URLSearchParams(location.search).get(name);
      return m ? decodeURIComponent(m) : '';
    }
    const MTURK = {
      assignmentId: getParam('assignmentId'),
      workerId: getParam('workerId'),
      hitId: getParam('hitId')
    };

    // Use default value like original code for proper scale
    let pixelsPerDegree = null; // Will default to 50 in the code, matching original
    let monitorWidthCm = 38;
    let viewingDistanceCm = 54;
    const apertureDeg = 5;
    const densityDotsPerDeg2 = 50;
    const dotDiameterDeg = 0.05;
    const dotSpeedDegPerSec = 2;
    const lifetimeMs = 200;
    const coherence = 0.40;
    const interleavedSets = 3;

    const fixationDurationMs = 1500;
    const faceDurationMs = 1500; // Same as adaptor duration in Exp 1
    const testDurationMs = 2000;
    const itiMinMs = 1000;
    const itiMaxMs = 2000;

    // Global canvas and context
    let globalCanvas = null;
    let globalCtx = null;
    let currentRafId = null;

    const timeline = [];

    // Helper functions
    function generateUUID() {
      return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
        const r = Math.random() * 16 | 0;
        const v = c === 'x' ? r : (r & 0x3 | 0x8);
        return v.toString(16);
      });
    }

    const sessionUUID = generateUUID();

    // IMAGE STIMULI CONFIG -------------------------------------------------
    // Use the star images in static/star/img. Each face has an L (left-gaze) and R (right-gaze) version.
    const FACE_IMAGE_PAIRS = [
      {
        L: "https://raw.githubusercontent.com/BackyardBrains/schema.backyardbrains.com/main/static/star/img/star-face-male-001-R.png",
        R: "https://raw.githubusercontent.com/BackyardBrains/schema.backyardbrains.com/main/static/star/img/star-face-male-001-L.png",
        L_blindfold: "https://raw.githubusercontent.com/BackyardBrains/schema.backyardbrains.com/main/static/star/img/star-face-male-001-R-Blindfold.png",
        R_blindfold: "https://raw.githubusercontent.com/BackyardBrains/schema.backyardbrains.com/main/static/star/img/star-face-male-001-L-Blindfold.png"
      }
      // Add more pairs here if you upload additional identities
    ];
    let TREE_IMAGE = null;
    const TREE_CANDIDATES = [
      "https://raw.githubusercontent.com/BackyardBrains/schema.backyardbrains.com/main/static/star/img/star-tree-001.png",
      "https://raw.githubusercontent.com/BackyardBrains/schema.backyardbrains.com/main/static/star/img/star-tree-002.png"
      // Add more tree images if needed
    ];
    const preloadedImgs = {};
    const attemptLog = []; // records { url, triedRemote, status }
    const GITHUB_RAW_BASE = 'https://raw.githubusercontent.com/BackyardBrains/schema.backyardbrains.com/main';
    function preloadImages(list) {
      console.log('Attempting to preload images:', list);
      return Promise.all(list.filter(Boolean).map(src => new Promise((resolve) => {
        const img = new Image();
        img.crossOrigin = 'anonymous';
        let triedRemote = false;
        let original = src;
        console.log('Loading image:', src);

        const record = (url, status, triedRemoteFlag) => {
          attemptLog.push({ url, status, triedRemote: !!triedRemoteFlag });
        };

        const fail = (url) => {
          console.warn('Failed to preload', url);
          record(url, 'failed', triedRemote);
          resolve(url);
        };

        img.onload = () => {
          // store under the original requested src (not the remote override)
          preloadedImgs[original] = img;
          record(img.src, 'loaded', triedRemote);
          resolve(original);
        };

        img.onerror = () => {
          // If this was a local absolute path (starts with /), try the GitHub raw URL once
          if (!triedRemote && original.startsWith('/')) {
            triedRemote = true;
            const remote = GITHUB_RAW_BASE + original;
            console.log('Local load failed for', original, '- trying remote', remote);
            // try remote URL
            img.onerror = () => fail(remote);
            img.src = remote;
            return;
          }
          fail(img.src || original);
        };

        // start loading
        try {
          img.src = src;
        } catch (e) {
          fail(src);
        }
      })));
    }
    // ----------------------------------------------------------------------

    async function sendDataToServer(payload, { timeoutMs = 8000, maxRetries = 2 } = {}) {
      const ctrl = new AbortController();
      const t = setTimeout(() => ctrl.abort(), timeoutMs);
      try {
        let attempt = 0;
        let lastError = null;
        const backoff = (n) => new Promise(r => setTimeout(r, Math.min(2000, 300 * Math.pow(2, n))));
        while (attempt <= maxRetries) {
          try {
            const res = await fetch('https://schema.backyardbrains.com/data', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify(payload),
              signal: ctrl.signal
            });
            const text = await res.text();
            // Try to interpret server response:
            // - Some servers return plain 'OK' (legacy), others return JSON {status:'ok', saved:...}.
            // Accept either as success. Log response for debugging.
            console.log('Upload response text:', text);
            let ok = false;
            try {
              const j = JSON.parse(text || '{}');
              if (j && (j.status === 'ok' || j.saved)) ok = true;
            } catch (e) {
              // not JSON
            }
            if (!ok && text && text.trim() === 'OK') ok = true;

            if (res.ok && ok) return { ok: true, status: res.status, statusText: res.statusText, body: text };
            lastError = { ok: false, status: res.status, statusText: res.statusText, body: text };
          } catch (err) {
            lastError = { ok: false, status: 0, statusText: String(err), body: '' };
          }
          attempt += 1;
          if (attempt <= maxRetries) {
            await backoff(attempt - 1);
          }
        }
        return lastError || { ok: false, status: 0, statusText: 'Unknown error', body: '' };
      } finally {
        clearTimeout(t);
      }
    }

    function initGlobalCanvas(width = 800, height = 800) {
      if (!globalCanvas) {
        globalCanvas = document.createElement('canvas');
        globalCanvas.id = 'rdk-canvas';
        globalCanvas.width = width;
        globalCanvas.height = height;
        globalCtx = globalCanvas.getContext('2d');
        globalCtx.imageSmoothingEnabled = false;
      }
      return globalCanvas;
    }

    function cleanup() {
      if (currentRafId) {
        cancelAnimationFrame(currentRafId);
        currentRafId = null;
      }
    }

    function randInt(min, max) { 
      return Math.floor(Math.random() * (max - min + 1)) + min; 
    }

    // Generate face SVG with proper gaze direction
    function generateFaceSVG(eyesOpen = true, lookingRight = true) {
      // Eye content based on whether eyes are open or blindfolded
      let eyeContent;
      if (eyesOpen) {
        if (lookingRight) {
          // Looking right - pupils shifted to the right
          eyeContent = `
            <!-- Left eye -->
            <circle cx="32" cy="35" r="7" fill="white" stroke="black" stroke-width="1"/>
            <circle cx="36" cy="35" r="3" fill="black"/>
            <!-- Right eye -->
            <circle cx="48" cy="35" r="7" fill="white" stroke="black" stroke-width="1"/>
            <circle cx="52" cy="35" r="3" fill="black"/>
          `;
        } else {
          // Looking left - pupils shifted to the left
          eyeContent = `
            <!-- Left eye -->
            <circle cx="32" cy="35" r="7" fill="white" stroke="black" stroke-width="1"/>
            <circle cx="28" cy="35" r="3" fill="black"/>
            <!-- Right eye -->
            <circle cx="48" cy="35" r="7" fill="white" stroke="black" stroke-width="1"/>
            <circle cx="44" cy="35" r="3" fill="black"/>
          `;
        }
      } else {
        // Blindfold - black rectangle across eyes
        eyeContent = `<rect x="25" y="30" width="30" height="10" fill="black"/>`;
      }
      
      // C-shaped ear - always on the side away from gaze direction
      const earPath = lookingRight ? 
        'M 24 38 C 20 35, 20 45, 24 42' :  // ear on left when looking right
        'M 56 38 C 60 35, 60 45, 56 42';   // ear on right when looking left
      
      // Nose points in direction of gaze
      const nosePath = lookingRight ? 
        'M 40 40 L 42 43' : 
        'M 40 40 L 38 43';
      
      return `
        <svg width="100" height="100" xmlns="http://www.w3.org/2000/svg">
          <!-- Oval face shape -->
          <ellipse cx="40" cy="45" rx="22" ry="28" fill="white" stroke="black" stroke-width="2"/>
          
          <!-- C-shaped ear -->
          <path d="${earPath}" fill="none" stroke="black" stroke-width="1.5"/>
          
          <!-- Eyes -->
          ${eyeContent}
          
          <!-- Nose -->
          <path d="${nosePath}" stroke="black" stroke-width="1"/>
          
          <!-- Line mouth -->
          <line x1="35" y1="52" x2="45" y2="52" stroke="black" stroke-width="1.5"/>
          
          <!-- Hair outline -->
          <path d="M 20 30 Q 40 20, 60 30" fill="none" stroke="black" stroke-width="1.5"/>
        </svg>
      `;
    }

    function generateTreeSVG() {
      return `
        <svg width="80" height="100" xmlns="http://www.w3.org/2000/svg">
          <!-- Tree trunk -->
          <rect x="35" y="60" width="10" height="30" fill="white" stroke="black" stroke-width="2"/>
          <!-- Tree foliage - overlapping circles -->
          <circle cx="40" cy="50" r="20" fill="white" stroke="black" stroke-width="2"/>
          <circle cx="30" cy="40" r="18" fill="white" stroke="black" stroke-width="2"/>
          <circle cx="50" cy="40" r="18" fill="white" stroke="black" stroke-width="2"/>
          <circle cx="40" cy="30" r="16" fill="white" stroke="black" stroke-width="2"/>
        </svg>
      `;
    }

    // Instructions
    const INSTR_IMAGES = {
      stare: "https://raw.githubusercontent.com/BackyardBrains/schema.backyardbrains.com/main/static/star/img/Stare_spot.png",
      stars: "https://raw.githubusercontent.com/BackyardBrains/schema.backyardbrains.com/main/static/star/img/Starfield.png"
    };

    const instructions = {
      type: jsPsychHtmlKeyboardResponse,
      stimulus: `
        <div class="center">
          <h2>The Starfield Game</h2>
          <p>You will be shown a field of moving dots. Most dots are moving randomly, but a portion are moving either LEFT or RIGHT.</p>
          <p>Please ignore the faces in the game — they are irrelevant to the task.</p>
          <p>Your full attention will be required for this experiment.</p>
          <p>Below are two images to help you understand the stimuli:</p>
          <div style="display:flex; justify-content:space-around; align-items:center; margin:12px 0;">
            <div style="text-align:center; max-width:48%;">
              <img src="${INSTR_IMAGES.stars}" alt="Starfield" style="width:320px; height:auto; border:1px solid #333; background:#fff;">
              <div style="color:#ddd; margin-top:6px;">Starfield (background)</div>
            </div>
            <div style="text-align:center; max-width:48%;">
              <img src="${INSTR_IMAGES.stare}" alt="Stare dot" style="width:120px; height:auto; border:1px solid #333; background:#fff;">
              <div style="color:#ddd; margin-top:6px;">Stare dot (focus)</div>
            </div>
          </div>
          <p>We will start with a few practice trials to help you get familiar with the game. Press any key to continue.</p>
        </div>
      `,
      choices: 'ALL_KEYS'
    };

    const practiceInstructions = {
      type: jsPsychHtmlKeyboardResponse,
      stimulus: `
        <div class="center">
          <h2>Practice Session</h2>
          <p>You will now complete 10 practice trials with just the random dots.</p>
          <p>Please stare at the center of the screen for each trial.</p>
          <p>Use the LEFT and RIGHT arrow keys to indicate the perceived direction of motion.</p>
          <p>You need to achieve at least 80% accuracy to proceed to the main experiment.</p>
          <p>Press any key to start practice.</p>
        </div>
      `,
      choices: 'ALL_KEYS'
    };

    timeline.push(instructions, practiceInstructions);

    // Fixation trial
    function fixationTrial({ width = 800, height = 800 } = {}) {
      return {
        type: jsPsychHtmlKeyboardResponse,
        choices: 'NO_KEYS',
        trial_duration: fixationDurationMs,
        stimulus: () => {
          const canvas = initGlobalCanvas(width, height);
          return canvas.outerHTML;
        },
        on_load: () => {
          cleanup();
          const canvas = document.getElementById('rdk-canvas');
          if (!canvas) return;
          
          const ctx = canvas.getContext('2d');
          const ppd = pixelsPerDegree || 50; // Default to 50 like original
          const radius = Math.max(1, Math.round(0.25 * ppd));
          const cx = Math.floor(width / 2);
          const cy = Math.floor(height / 2);
          
          ctx.fillStyle = '#808080';
          ctx.fillRect(0, 0, width, height);
          ctx.fillStyle = '#000000';
          ctx.beginPath();
          ctx.arc(cx, cy, radius, 0, Math.PI * 2);
          ctx.fill();
        }
      };
    }

    // Face-Tree stimulus using real images (falls back to SVG tree if TREE_IMAGE missing)
    function faceTreeStimulus({ width = 800, height = 800, faceOnLeft = true, eyesOpen = true } = {}) {
      return {
        type: jsPsychHtmlKeyboardResponse,
        choices: 'NO_KEYS',
        trial_duration: faceDurationMs,
        stimulus: () => {
          // Choose a face identity (random) and pick the correct gaze version
          const pairIndex = Math.floor(Math.random() * FACE_IMAGE_PAIRS.length);
          const pair = FACE_IMAGE_PAIRS[pairIndex];
          // If face is on left, it should look right => use R image. If on right, use L image.
          let faceSrc;
          if (eyesOpen) {
            faceSrc = faceOnLeft ? pair.R : pair.L;
          } else {
            faceSrc = faceOnLeft ? pair.R_blindfold : pair.L_blindfold;
          }
          const treeSrc = TREE_IMAGE;

          // Positioning
          const spacing = 300;
          const centerX = width / 2;
          const centerY = height / 2;
          const faceX = faceOnLeft ? centerX - spacing/2 - 60 : centerX + spacing/2 - 60;
          const treeX = faceOnLeft ? centerX + spacing/2 - 40 : centerX - spacing/2 - 40;

          const treeHTML = (treeSrc && preloadedImgs[treeSrc]) ?
            `<img class="tree-image" src="${treeSrc}" style="position:absolute; left:${treeX}px; top:${centerY-60}px; width:110px; height:auto;">` :
            `<div style="position:absolute; left:${treeX}px; top:${centerY-60}px;">${generateTreeSVG()}</div>`;

          // Face image fallback to SVG if image not available
          const faceHTML = (preloadedImgs[faceSrc]) ?
            `<img class="face-image" src="${faceSrc}" style="position:absolute; left:${faceX}px; top:${centerY-60}px; width:120px; height:auto;">` :
            `<div style="position:absolute; left:${faceX}px; top:${centerY-60}px;">${generateFaceSVG(eyesOpen, faceOnLeft)}</div>`;

          return `
            <div class="stimulus-container" style="width:${width}px; height:${height}px; position:relative;">
              ${faceHTML}
              ${treeHTML}
            </div>
          `;
        },
        on_finish: (data) => {
          data.phase = 'face-tree-stimulus';
          data.faceOnLeft = faceOnLeft;
          data.eyesOpen = eyesOpen;
          data.impliedDirection = faceOnLeft ? 0 : 180;
        }
      };
    }

    // RDK trial (same as Experiment 1)
    function rdkTrial({
      width = 800,
      height = 800,
      directionDeg = 180,
      durationMs = 2000,
      numSets = interleavedSets
    } = {}) {
      const ppd = pixelsPerDegree || 50; // Default to 50 like original
      const aperturePx = Math.round(apertureDeg * ppd);
      const apertureHalf = Math.floor(aperturePx / 2);
      const centerX = Math.floor(width / 2);
      const centerY = Math.floor(height / 2);
      const leftBound = centerX - apertureHalf;
      const rightBound = centerX + apertureHalf;
      const topBound = centerY - apertureHalf;
      const bottomBound = centerY + apertureHalf;

      const numDots = Math.max(50, Math.round(densityDotsPerDeg2 * apertureDeg * apertureDeg));
      const coherentCount = Math.round(numDots * coherence);
      const dotRadius = Math.max(1, (dotDiameterDeg * ppd) / 2);
      const dotSpeedPxPerSec = dotSpeedDegPerSec * ppd;
      const lifetimeSec = lifetimeMs / 1000;

      return {
        type: jsPsychHtmlKeyboardResponse,
        choices: ['ArrowLeft','ArrowRight'],
        trial_duration: durationMs,
        response_ends_trial: true,
        stimulus: () => {
          const canvas = initGlobalCanvas(width, height);
          return canvas.outerHTML;
        },
        on_load: () => {
          cleanup();
          
          const canvas = document.getElementById('rdk-canvas');
          if (!canvas) return;
          
          const ctx = canvas.getContext('2d');

          const radians = directionDeg * Math.PI / 180;
          const coherentVx = Math.cos(radians) * dotSpeedPxPerSec;
          const coherentVy = Math.sin(radians) * dotSpeedPxPerSec;

          function randInAperture() {
            return {
              x: leftBound + Math.random() * aperturePx,
              y: topBound + Math.random() * aperturePx
            };
          }

          function makeDot(isCoherent) {
            const dot = {
              ...randInAperture(),
              ageSec: 0,
              isCoherent
            };
            dot.vx = coherentVx;
            dot.vy = coherentVy;
            return dot;
          }

          // Initialize dot sets
          const sets = [];
          const dotsPerSet = Math.floor(numDots / numSets);
          const coherentPerSet = Math.floor(coherentCount / numSets);
          
          for (let s = 0; s < numSets; s++) {
            const dots = [];
            for (let i = 0; i < coherentPerSet; i++) {
              dots.push(makeDot(true));
            }
            for (let i = coherentPerSet; i < dotsPerSet; i++) {
              dots.push(makeDot(false));
            }
            sets.push(dots);
          }

          // Distribute remaining dots
          let remaining = numDots - sets.reduce((sum, set) => sum + set.length, 0);
          let remainingCoherent = coherentCount - sets.reduce((sum, set) => sum + set.filter(d => d.isCoherent).length, 0);
          
          for (let i = 0; i < remaining; i++) {
            const isCoherent = i < remainingCoherent;
            sets[i % numSets].push(makeDot(isCoherent));
          }

          function respawn(dot) {
            const p = randInAperture();
            dot.x = p.x;
            dot.y = p.y;
            dot.ageSec = 0;
            dot.vx = coherentVx;
            dot.vy = coherentVy;
          }

          function drawAllDots() {
            ctx.fillStyle = '#808080';
            ctx.fillRect(0, 0, width, height);
            
            ctx.strokeStyle = '#606060';
            ctx.lineWidth = 1;
            ctx.strokeRect(leftBound, topBound, aperturePx, aperturePx);
            
            ctx.fillStyle = '#000000';
            const dotSize = Math.max(1, Math.round(dotRadius * 2));
            
            ctx.beginPath();
            for (const set of sets) {
              for (const d of set) {
                ctx.rect(Math.floor(d.x - dotRadius), Math.floor(d.y - dotRadius), dotSize, dotSize);
              }
            }
            ctx.fill();
          }

          function updateSet(activeSetIdx, dtSec) {
            const set = sets[activeSetIdx];
            for (const d of set) {
              if (d.isCoherent) {
                d.x += d.vx * dtSec;
                d.y += d.vy * dtSec;
              } else {
                const p = randInAperture();
                d.x = p.x;
                d.y = p.y;
              }

              if (d.isCoherent) {
                while (d.x < leftBound) d.x += aperturePx;
                while (d.x >= rightBound) d.x -= aperturePx;
                while (d.y < topBound) d.y += aperturePx;
                while (d.y >= bottomBound) d.y -= aperturePx;
              }

              d.ageSec += dtSec * numSets;
              if (d.ageSec >= lifetimeSec) {
                respawn(d);
              }
            }
          }

          let start = null;
          let frame = 0;
          let lastTs = null;
          const targetFps = 60;
          const frameDuration = 1000 / targetFps;

          function step(ts) {
            if (start === null) start = ts;
            const elapsed = ts - start;
            
            if (elapsed >= durationMs) {
              cleanup();
              return;
            }

            const dtMs = lastTs == null ? frameDuration : (ts - lastTs);
            lastTs = ts;
            const dtSec = dtMs / 1000;

            const activeSetIdx = frame % numSets;
            updateSet(activeSetIdx, dtSec);
            drawAllDots();
            frame += 1;

            currentRafId = requestAnimationFrame(step);
          }

          currentRafId = requestAnimationFrame(step);
        },
        on_finish: (data) => {
          cleanup();
          const correctKey = directionDeg === 0 ? 'arrowright' : 'arrowleft';
          data.correct = jsPsych.pluginAPI.compareKeys(data.response, correctKey);
          data.direction = directionDeg;
          data.coherence = coherence;
          data.lifetimeMs = lifetimeMs;
          data.numSets = numSets;
          data.apertureDeg = apertureDeg;
          data.ppd = pixelsPerDegree || 50;
        }
      };
    }

    // Practice trial
    function practiceTrial({ directionDeg = 180 }) {
      const itiMs = randInt(itiMinMs, itiMaxMs);
      
      const tooSlowScreen = {
        type: jsPsychHtmlKeyboardResponse,
        choices: 'NO_KEYS',
        trial_duration: 1500,
        stimulus: `<div class="center"><h3>Too Slow!</h3><p>Please respond faster.</p></div>`
      };

      const test = {
        ...rdkTrial({ directionDeg: directionDeg, durationMs: testDurationMs }),
        on_finish: (data) => {
          const correctKey = directionDeg === 0 ? 'arrowright' : 'arrowleft';
          data.correct = jsPsych.pluginAPI.compareKeys(data.response, correctKey);
          data.phase = 'practice';
          data.direction = directionDeg;
        }
      };

      return {
        timeline: [
          { 
            type: jsPsychHtmlKeyboardResponse, 
            choices: 'NO_KEYS', 
            trial_duration: itiMs, 
            stimulus: '',
            on_load: cleanup
          },
          fixationTrial(),
          { timeline: [ test ], conditional_function: () => true },
          { 
            timeline: [ tooSlowScreen ], 
            conditional_function: () => {
              const last = jsPsych.data.get().last(1).values()[0];
              return (typeof last.response === 'undefined' || last.response === null);
            }
          }
        ]
      };
    }

    // MODIFIED: Main experimental trial to accept forced congruency
    function experimentalTrial({ faceOnLeft, eyesOpen, forceCongruent = null }) {
      const impliedDirection = faceOnLeft ? 0 : 180; // rightward : leftward
      const congruent = forceCongruent !== null ? forceCongruent : Math.random() < 0.5;
      const testDirection = congruent ? impliedDirection : (impliedDirection === 0 ? 180 : 0);
      const itiMs = randInt(itiMinMs, itiMaxMs);
      
      const tooSlowScreen = {
        type: jsPsychHtmlKeyboardResponse,
        choices: 'NO_KEYS',
        trial_duration: 1500,
        stimulus: `<div class="center"><h3>Too Slow!</h3><p>Please respond faster.</p></div>`
      };

      const test = {
        ...rdkTrial({ directionDeg: testDirection, durationMs: testDurationMs }),
        on_finish: (data) => {
          const correctKey = testDirection === 0 ? 'arrowright' : 'arrowleft';
          data.correct = jsPsych.pluginAPI.compareKeys(data.response, correctKey);
          data.phase = 'test';
          data.congruent = congruent;
          data.eyesOpen = eyesOpen;
          data.faceOnLeft = faceOnLeft;
          data.impliedDirection = impliedDirection;
          data.testDirection = testDirection;
        }
      };

      return {
        timeline: [
          { 
            type: jsPsychHtmlKeyboardResponse, 
            choices: 'NO_KEYS', 
            trial_duration: itiMs, 
            stimulus: '',
            on_load: cleanup
          },
          fixationTrial(),
          faceTreeStimulus({ faceOnLeft: faceOnLeft, eyesOpen: eyesOpen }),
          { timeline: [ test ], conditional_function: () => true },
          { 
            timeline: [ tooSlowScreen ], 
            conditional_function: () => {
              const last = jsPsych.data.get().last(1).values()[0];
              return (typeof last.response === 'undefined' || last.response === null);
            }
          }
        ]
      };
    }

    // Build practice trials
    const practiceTrials = [];
    for (let i = 0; i < 10; i++) {
      const direction = Math.random() < 0.5 ? 0 : 180;
      practiceTrials.push(practiceTrial({ directionDeg: direction }));
    }

    // Practice check
    const practiceCheck = {
      type: jsPsychHtmlKeyboardResponse,
      choices: 'NO_KEYS',
      trial_duration: 0,
      stimulus: '',
      on_load: () => {
        const data = jsPsych.data.get();
        const practiceData = data.filter({ phase: 'practice' });
        const n = practiceData.count();
        const correct = practiceData.filter({ correct: true }).count();
        const accuracy = n > 0 ? correct / n : 0;
        
        if (accuracy < 0.8) {
          document.body.innerHTML = `
            <div class="center">
              <h2>Practice Session Complete</h2>
              <p>Your accuracy was only ${Math.round(accuracy * 100)}% (${correct}/${n} correct).</p>
              <p>You need at least 80% accuracy to proceed with the game.</p>
              <p>Please return to the main page and try again.</p>
            </div>
          `;
          jsPsych.endExperiment();
        }
      }
    };

    const practiceSuccess = {
      type: jsPsychHtmlKeyboardResponse,
      stimulus: `
        <div class="center">
          <h2>Practice Session Complete</h2>
          <p>Great job! You've successfully completed the practice session.</p>
          <p>Now you'll proceed to the main game, this time with some faces in the background.</p>
          <p>The game is the same, focus on the center dot, then quickly respond to the direction of the moving dots.</p>
          <p>You will need to achieve at least 80% accuracy for the task to be approved.</p>
          <p>Press any key to begin.</p>
        </div>
      `,
      choices: 'ALL_KEYS'
    };

    // MODIFIED: Build main experimental trials with balanced conditions
    const experimentalSpecs = [];
    const trialsPerCondition = 15; // 15 × 4 = 60 total trials

    for (let i = 0; i < trialsPerCondition; i++) {
      experimentalSpecs.push({ eyesOpen: true, congruent: true, faceOnLeft: Math.random() < 0.5 });
      experimentalSpecs.push({ eyesOpen: true, congruent: false, faceOnLeft: Math.random() < 0.5 });
      experimentalSpecs.push({ eyesOpen: false, congruent: true, faceOnLeft: Math.random() < 0.5 });
      experimentalSpecs.push({ eyesOpen: false, congruent: false, faceOnLeft: Math.random() < 0.5 });
    }

    // Fisher-Yates shuffle
    for (let i = experimentalSpecs.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [experimentalSpecs[i], experimentalSpecs[j]] = [experimentalSpecs[j], experimentalSpecs[i]];
    }

    // Create trials with forced congruency
    const experimentalTrials = experimentalSpecs.map(spec => 
      experimentalTrial({ 
        faceOnLeft: spec.faceOnLeft, 
        eyesOpen: spec.eyesOpen,
        forceCongruent: spec.congruent 
      })
    );

    // Add trials to timeline
    timeline.push({ timeline: practiceTrials });
    timeline.push(practiceCheck);
    timeline.push({
      timeline: [practiceSuccess],
      conditional_function: () => {
        const data = jsPsych.data.get();
        const practiceData = data.filter({ phase: 'practice' });
        const n = practiceData.count();
        const correct = practiceData.filter({ correct: true }).count();
        const accuracy = n > 0 ? correct / n : 0;
        return accuracy >= 0.8;
      }
    });
    timeline.push({ timeline: experimentalTrials });

    // Final results
    timeline.push({
      type: jsPsychHtmlKeyboardResponse,
      choices: 'NO_KEYS',
      trial_duration: 0,
      stimulus: '',
      on_load: () => {
        showResultsAndMenu();
      }
    });

    // MODIFIED: Updated showResultsAndMenu function
    async function showResultsAndMenu() {
      cleanup();
      
      const data = jsPsych.data.get();
      const tests = data.filter({ phase: 'test' });
      const practiceData = data.filter({ phase: 'practice' }); // Add this line
      const n = tests.count();
      const acc = n ? Math.round(tests.filter({ correct: true }).count() / n * 100) : 0;
      const meanRt = Math.round(tests.select('rt').mean() || 0);

      // Build session metadata
      const ua = navigator.userAgent || '';
      const isWindows = /Windows/i.test(ua);
      const isMac = /Macintosh|Mac OS X/i.test(ua);
      const isLinux = /Linux/i.test(ua);
      const osName = isWindows ? 'Windows' : isMac ? 'Mac' : isLinux ? 'Linux' : 'Unknown';
      const browserName = /Edg\//.test(ua) ? 'Edge' : /Chrome\//.test(ua) ? 'Chrome' : /Firefox\//.test(ua) ? 'Firefox' : /Safari\//.test(ua) ? 'Safari' : 'Unknown';
      const screenResolution = `${window.screen.width}x${window.screen.height}`;
      const browserViewport = `${window.innerWidth}x${window.innerHeight}`;

      // MODIFIED: Add trial counter for main trials
      let trialCounter = 0;
      const trialsMinimal = tests.values().map(t => ({
        trial_number: trialCounter++, // Add sequential numbering starting from 0
        trial_index: t.trial_index,
        rt: t.rt,
        correct: t.correct,
        response: (typeof t.response === 'string') ? (t.response.toLowerCase().includes('left') ? 'ArrowLeft' : 'ArrowRight') : t.response,
        congruent: t.congruent,
        eyesOpen: t.eyesOpen,
        faceOnLeft: t.faceOnLeft,
        impliedDirection: t.impliedDirection,
        testDirection: t.testDirection
      }));

      // ADDED: Practice trials data
      const practiceTrialsData = practiceData.values().map((t, idx) => ({
        trial_number: idx,
        rt: t.rt,
        correct: t.correct,
        direction: t.direction
      }));

      const payload = {
        experiment: 'rdk-face-1',
        UUID: sessionUUID,
        data: {
          session: {
            experiment_version: '1.2',
            treatment: 'faces',
            file_version: '1.2',
            totalTrials: n,
            session_group: 'default',
            browserData: {
              os: osName,
              browser: browserName,
              screenResolution: screenResolution,
              browserViewport: browserViewport
            },
            calibration: {
              monitorWidthCm: monitorWidthCm,
              viewingDistanceCm: viewingDistanceCm,
              pixelsPerDegree: Math.round((pixelsPerDegree || 50) * 10) / 10
            },
            parameters: {
              coherence: coherence,
              apertureDeg: apertureDeg,
              dotSpeedDegPerSec: dotSpeedDegPerSec,
              lifetimeMs: lifetimeMs,
              fixationDurationMs: fixationDurationMs,
              faceDurationMs: faceDurationMs,
              testDurationMs: testDurationMs
            },
            mturk: {
              assignmentId: MTURK.assignmentId,
              workerId: MTURK.workerId,
              hitId: MTURK.hitId
            }
          },
          trials: trialsMinimal,
          practice: {  // ADDED: Practice section
            trials: practiceTrialsData,
            meanRT: Math.round(practiceData.select('rt').mean() || 0),
            accuracy: practiceData.count() > 0 ? 
              Math.round(practiceData.filter({ correct: true }).count() / practiceData.count() * 100) : 0
          }
        }
      };

      // IMPORTANT: Data is sent to server regardless of accuracy
      let uploadResult = await sendDataToServer(payload, { timeoutMs: 8000, maxRetries: 2 });
      let saveMsg = uploadResult.ok ? 'Saved to server.' : `Save failed (${uploadResult.status} ${uploadResult.statusText}).`;
      
      const container = document.createElement('div');
      container.className = 'center';

      // Check accuracy and show appropriate content
      if (acc >= 80) {
        // SUCCESS: Build Google Form URL with parameters
        const hasUuidEntry = typeof GOOGLE_FORM_ENTRY_ID === 'string' && GOOGLE_FORM_ENTRY_ID.trim().length > 0;
        const params = new URLSearchParams();
        params.set('usp', 'pp_url');
        
        // Add UUID if entry ID is configured
        if (hasUuidEntry) {
          params.set(`entry.${GOOGLE_FORM_ENTRY_ID}`, sessionUUID);
        }
        
        // Add MTurk parameters if entry IDs are configured
        if (GOOGLE_FORM_ASSIGNMENT_ENTRY_ID && GOOGLE_FORM_ASSIGNMENT_ENTRY_ID.trim().length > 0) {
          params.set(`entry.${GOOGLE_FORM_ASSIGNMENT_ENTRY_ID}`, MTURK.assignmentId || '');
        }
        if (GOOGLE_FORM_WORKER_ENTRY_ID && GOOGLE_FORM_WORKER_ENTRY_ID.trim().length > 0) {
          params.set(`entry.${GOOGLE_FORM_WORKER_ENTRY_ID}`, MTURK.workerId || '');
        }
        if (GOOGLE_FORM_HIT_ENTRY_ID && GOOGLE_FORM_HIT_ENTRY_ID.trim().length > 0) {
          params.set(`entry.${GOOGLE_FORM_HIT_ENTRY_ID}`, MTURK.hitId || '');
        }
        
        const formUrl = `${GOOGLE_FORM_BASE_URL}?${params.toString()}`;

        container.innerHTML = `
          <h2 style="margin-bottom: 16px;">Experiment Complete</h2>
          <p>Your overall accuracy was <strong>${acc}%</strong>.</p>
          <p id="upload-status" style="margin-bottom: 16px;">${saveMsg}</p>
          <p style="margin-bottom: 24px;">Please click the button below to open the final form and complete the experiment.</p>
          <p><a id="btn-form" href="${formUrl}" target="_blank" rel="noopener noreferrer" style="display:inline-block; padding:10px 16px; background:#222; color:#fff; text-decoration:none; border-radius:6px;">Open Form</a></p>
          ${hasUuidEntry ? '' : '<p style="margin-top:20px; font-size:14px; color:#ddd;">Note: Configure GOOGLE_FORM_ENTRY_ID in the script to prefill the UUID in your form.</p>'}
        `;

        document.body.innerHTML = '';
        document.body.appendChild(container);

        // Optional: auto-redirect to form after successful upload
        if (uploadResult.ok && acc >= 80) {
          setTimeout(() => {
            window.location.href = formUrl;
          }, 2000); // 2 second delay to allow user to see the success message
        }

      } else {
        // FAILURE: Accuracy is less than 80% - NO FORM SHOWN
        container.innerHTML = `
          <h2 style="margin-bottom: 16px;">Experiment Incomplete</h2>
          <p>Your overall accuracy was <strong>${acc}%</strong>.</p>
          <p>As stated in the instructions, an accuracy of 80% or higher is required to complete the experiment.</p>
          <p>Your data has been saved, but you will not be redirected to the completion form.</p>
          <p id="upload-status" style="margin-top: 20px;">${saveMsg}</p>
        `;
        
        document.body.innerHTML = '';
        document.body.appendChild(container);
      }
    }

    // Initialize canvas on startup
    initGlobalCanvas();

    // Preload face/tree images then start experiment
    const INSTR_IMAGES_URLS = [
      INSTR_IMAGES.stare,
      INSTR_IMAGES.stars
    ];

    const imgsToPreload = FACE_IMAGE_PAIRS.reduce((acc, p) => {
      if (p.L) acc.push(p.L);
      if (p.R) acc.push(p.R);
      if (p.L_blindfold) acc.push(p.L_blindfold);
      if (p.R_blindfold) acc.push(p.R_blindfold);
      return acc;
    }, []).concat(TREE_CANDIDATES).concat(INSTR_IMAGES_URLS).filter(Boolean);

    preloadImages(imgsToPreload).then(() => {
      // Pick the first tree candidate that actually loaded
      for (const c of TREE_CANDIDATES) {
        if (preloadedImgs[c]) {
          TREE_IMAGE = c;
          console.log('Using tree image:', TREE_IMAGE);
          break;
        }
      }

      // Check how many face images loaded
      let numFacesLoaded = FACE_IMAGE_PAIRS.reduce((acc, p) => acc + (preloadedImgs[p.L] ? 1 : 0) + (preloadedImgs[p.R] ? 1 : 0), 0);
      if (numFacesLoaded === 0) {
        console.error('No face images loaded. The experiment will use SVG fallbacks. Check FACE_IMAGE_DIR and filenames.');
        const warn = document.createElement('div');
        warn.style.position = 'fixed';
        warn.style.left = '10px';
        warn.style.top = '10px';
        warn.style.padding = '8px 12px';
        warn.style.background = '#ffdddd';
        warn.style.color = '#660000';
        warn.style.zIndex = 9999;
        warn.innerText = 'Warning: face images not loaded — using SVG fallbacks.';
        document.body.appendChild(warn);
      }

      jsPsych.run(timeline);
    }).catch((e) => {
      console.warn('Image preload encountered an error:', e);
      // If preload fails, run experiment anyway
      jsPsych.run(timeline);
    });
  </script>
</html>
